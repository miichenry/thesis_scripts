from optparse import OptionParser
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from obspy.core import read
from matplotlib.dates import DateFormatter
from datetime import datetime
import os
import glob
from obspy.signal.filter import bandpass

#Script to convert Cross correlation functions from MSnoise output to *.npy array. 
#This script reads the data from the folder STACKS (generated by MSnoise)
# *.npy Ready to use with noisePY to apply stretching method.
#IMPORTANT. This stript also reads the filters.csv file from MSnoise. It can be get using --> $msnoise db dump

def main():
        Usage= "Usage: stacks2numpy_options.py -c components [NZ] -f filter [01]) "
        parser = OptionParser(usage=Usage)
        parser.add_option("-c", "--component", action="store",
                        type="string", dest="comp_", help="cross correlation component. e.g. NZ")
        parser.add_option("-f", "--filter", action="store",
                        type="string", dest="filt_number", help="see MSnoise filter number e.g. 01")
        parser.add_option("-s", "--stack_days", action="store",
                        type="string", dest="stack_days", help="Choose one option of stack days e.g. 001 or 005, etc.")
        parser.add_option("-p", "--station_pair", action="store",
                        type="string", dest="station_pair", help="Station pair. e.g. KO_GAZ_KO_KMRS. MSnoise format ")
        (options, args) = parser.parse_args()
        if options.comp_ == None or options.filt_number == None:
            parser.error("At least two arguments are required")
        comp_        = options.comp_
        filt_number  = options.filt_number
        stack_days   = options.stack_days
        if stack_days == None:
            stack_days = '001'
        station_pair = options.station_pair
        if station_pair == None:
            station_pair = 'KO_GAZ_KO_KMRS'

# list to store files
        stacks = []
        filelist = glob.glob('STACKS/'+filt_number+'/'+stack_days+'_DAYS/'+comp_+'/'+station_pair+'/*.MSEED')
        print('reading data from: ' + 'STACKS/'+filt_number+'/'+stack_days+'_DAYS/'+comp_+'/'+station_pair+'/')
        filelist.sort() #sort files. Otherwise plotting issues 
# Iterate directory
        for file_name in filelist: 
            if file_name.endswith('.MSEED'): #getting all mseed files
                stacks.append(file_name)
        #print(stacks)

        lst_arr = []
        times   = []
        for i in stacks:
            read_mseed = read(i) #reading mseed with obspy
            st  = read_mseed[0]
            #tr  = st[0]
            smpl_rate = st.stats.sampling_rate #this is just to retrieve the sampling rate
        #print(read_mseed)
            arr_mseed = np.array(read_mseed) #creating an array for each cross correlation
        #print(arr_mseed.shape)
            lst_arr.append(arr_mseed[0,:])
    
            yyyy = i[-16:-12]
            mm   = i[-11:-9]
            dd   = i[-8:-6]
            dates = yyyy+'-'+mm+'-'+dd
            date_time_obj = datetime.strptime(dates, '%Y-%m-%d') #extracting date-times from file names
            times.append(date_time_obj)
            #print(times)
        #print(smpl_rate)
        #print(lst_arr)

        #getting filter values from filters.csv
        filt_inf = pd.read_csv(r'filters.csv') #pandas read a file name as a variable
        mwcs_f = pd.DataFrame(filt_inf, columns=['ref','low','high'])#retrieving filters
        #print(mwcs_f)
        str_filt_number = filt_number
        filt_number = int(filt_number)
        ind_   = filt_number-1
        fmin   = mwcs_f._get_value(ind_, 'low')
        fmax   = mwcs_f._get_value(ind_, 'high')
        both_f = str(fmin)+'_'+str(fmax)
        print('Stations', station_pair, '|','Components', comp_, '|', 'Filt_number', str_filt_number, 
                'frequency band:', both_f + 'Hz', '|', 'stack', stack_days)
        
               
        AA = np.stack((lst_arr[0:]), axis=-1) #stacking all the CC arrays in -1 axes to get the correct dimensions
        print('Array shape ', AA.shape)

        N = AA.shape[0]
        fs = smpl_rate #20
        dt = 1/fs
        maxlag = ((N-1)/2 ) * dt #arranging maxlag
        tlag = np.arange(-maxlag,maxlag+dt,dt) #total lag. + and -

        with open(station_pair+'_comp_'+comp_+'_filt'+both_f+'_stack'+stack_days+'.npy', 'wb') as f:
            np.savez(f, CCdata=AA, tlag=tlag, times=times, sampling_rate=smpl_rate, fmin=fmin, fmax=fmax, comp=comp_, maxlag=maxlag, stack=int(stack_days))

        data = AA
        vmax = np.nanmax(data) * 0.9
        fig, ax = plt.subplots(1,1,figsize=(10,10))
        ax.pcolor(times,tlag,data, cmap='seismic', vmin=-vmax, vmax=vmax, shading='auto')
        ax.set_ylabel("Lag time (s)")
        ax.set_xlabel("Subwindow")
        ax.set_title("Converted data " + station_pair + " Components "+comp_ + 
            ". Filter " + both_f + 'Hz. ' + ' Moving window ' + stack_days )
        ax.xaxis.set_major_formatter(DateFormatter("%Y-%m-%d"))
        fig.autofmt_xdate()
        plt.axhline(0, lw=0.5, c='k')
        plt.grid()
        plt.tight_layout()
        #plt.show()

        #plot ccftime
        #fig, ax = plt.subplots(1,1,figsize=(10,10))
        #for i, wf in enumerate(data.T):
        #    wf_filt = bandpass(wf, 0.1, 1.4, 20, zerophase=True)
        #    ax.plot(tlag,wf_filt/np.nanmax(wf_filt)+i, "k")
        #plt.show()

if __name__ == "__main__":
	main()
